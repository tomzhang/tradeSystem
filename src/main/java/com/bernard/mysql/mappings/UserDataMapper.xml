<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
		"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.bernard.mysql.dao.UserDataMapper">

	<insert id="inserUserOrder" parameterType="com.bernard.mysql.dto.Order">
		INSERT INTO T_USER_ORDER
        (ORDER_ID,ORDER_TIME,ACCOUNT,ASSET_PAIR,ORDER_SIDE,
        ORDER_TYPE,SURVIVE_TIME,AMOUNT,PRICE,STATE,
        REMAIN,ASSET_LIMIT,LOCK_VERSION)
        VALUES
        (#{orderID},#{orderTime},#{account},#{assetPair},#{orderSide,typeHandler=org.apache.ibatis.type.EnumTypeHandler},
        #{orderType,typeHandler=org.apache.ibatis.type.EnumTypeHandler},#{surviveTime},#{amount},#{price},#{state,typeHandler=org.apache.ibatis.type.EnumTypeHandler},
        #{remain},#{AssertLimit},#{LockVersion})
	</insert>

	<update id="updateUserOrder" parameterType="com.bernard.mysql.dto.Order">
		UPDATE T_USER_ORDER SET STATE= #{state,typeHandler=org.apache.ibatis.type.EnumTypeHandler},
		REMAIN=#{remain},LOCK_VERSION =#{LockVersion} WHERE ORDER_ID =#{orderID} AND LOCK_VERSION =#{LockVersion}-1 AND ACCOUNT =#{account}
	</update>

	<resultMap type="com.bernard.mysql.dto.UserAsset" id="userAssetMap">
		<result property="account" column="ACCOUNT"/>
		<result property="totalAmount" column="TOTAL_AMOUNT"/>
		<result property="aviliable" column="AIVILIABLE"/>
		<result property="lockVersion" column="LOCK_VERSION"/>
		<result property="updateTime" column="UPDATE_TIME"/>
		<result property="liquidationTime" column="LIQUIDATION_TIME"/>
	</resultMap>
	<select id="queryUserAssert" resultMap="userAssetMap" parameterType="com.bernard.mysql.dto.UserAsset">
		SELECT * FROM T_USER_ASSET_${param2} WHERE ACCOUNT= #{param1}
	</select>

	<update id="lockUserAssert">
		UPDATE T_USER_ASSET_${param2} SET LOCK_VERSION =#{param7}, AIVILIABLE=#{param5},UPDATE_TIME=#{param8} WHERE
		ACCOUNT=#{param1} AND LOCK_VERSION =#{param6}
	</update>

	<update id="updateUserAssert">
		UPDATE T_USER_ASSET_${param2} SET LOCK_VERSION=LOCK_VERSION+1,AIVILIABLE=CONVERT(AIVILIABLE,DECIMAL(32,8))+CONVERT (#{param4},DECIMAL(32,8)),TOTAL_AMOUNT=CONVERT (TOTAL_AMOUNT,DECIMAL(32,8))+CONVERT (#{param3},DECIMAL(32,8)),UPDATE_TIME=#{param5} WHERE ACCOUNT=#{param1}
	</update>

	<update id="unlockUserAssertWhenFail">
		unlockUserAssertWhenFail(String account, String asset, String amountToUnlock, Date updateTime)
		UPDATE T_USER_ASSET_${param2} SET LOCK_VERSION = LOCK_VERSION+1,AIVILIABLE
		=CONVERT(AIVILIABLE,DECIMAL(32,8))+CONVERT (#{param3},DECIMAL(32,8)),UPDATE_TIME=#{param4} WHERE ACCOUNT
		=#{param}
	</update>


	<resultMap type="com.bernard.mysql.dto.Order" id="userOrderMap">
		<result property="orderID" column="ORDER_ID"/>
		<result property="orderTime" column="ORDER_TIME"/>
		<result property="account" column="ACCOUNT"/>
		<result property="assetPair" column="ASSET_PAIR"/>
		<result property="orderSide" column="ORDER_SIDE" typeHandler="org.apache.ibatis.type.EnumTypeHandler"/>
		<result property="orderType" column="ORDER_TYPE" typeHandler="org.apache.ibatis.type.EnumTypeHandler"/>
		<result property="surviveTime" column="SURVIVE_TIME"/>
		<result property="amount" column="AMOUNT"/>
		<result property="price" column="PRICE"/>
		<result property="state" column="STATE" typeHandler="org.apache.ibatis.type.EnumTypeHandler"/>
		<result property="remain" column="REMAIN"/>
		<result property="AssertLimit" column="ASSET_LIMIT"/>
		<result property="LockVersion" column="LOCK_VERSION"/>
	</resultMap>

	<select id="queryUserOrder" resultMap="userOrderMap" parameterType="com.bernard.mysql.dto.Order">
		SELECT * FROM T_USER_ORDER WHERE ORDER_ID= #{0} AND ACCOUNT = #{1}
	</select>

	<select id="queryMatchOrders" resultMap="userOrderMap" parameterType="com.bernard.mysql.dto.Order">
		SELECT * FROM T_USER_ORDER WHERE ORDER_ID=#{0} OR ORDER_ID =#{2}
	</select>

	<resultMap id="queryAssetResult" type="java.lang.String">
		<result column="ASSET" property="asset" jdbcType="VARCHAR"/>
	</resultMap>
	<select id="queryAllAsset" resultMap="queryAssetResult" parameterType="java.lang.String">
		SELECT * FROM T_ASSET
	</select>

	<resultMap id="queryAssetPairResult" type="java.lang.String">
		<result column="PAIR" property="assetPair" jdbcType="VARCHAR"/>
	</resultMap>
	<select id="queryAllAssetPair" resultMap="queryAssetPairResult" parameterType="java.lang.String">
		SELECT * FROM T_ASSET_PAIR
	</select>


    <select id="existTable" parameterType="String" resultType="Integer">
        SELECT COUNT(*) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA='tradeCenter' AND TABLE_NAME=#{0} ;
    </select>

    <update id="createNewTable" parameterType="String">
        CREATE TABLE ${tableName} (
        `ID` int(11) NOT NULL AUTO_INCREMENT ,
        `ACCOUNT` varchar(255) CHARACTER SET latin1 COLLATE latin1_swedish_ci NULL DEFAULT NULL ,
        `TOTAL_AMOUNT` varchar(255) CHARACTER SET latin1 COLLATE latin1_swedish_ci NULL DEFAULT NULL ,
        `AIVILIABLE` varchar(255) CHARACTER SET latin1 COLLATE latin1_swedish_ci NULL DEFAULT NULL ,
        `LOCK_VERSION` varchar(255) CHARACTER SET latin1 COLLATE latin1_swedish_ci NULL DEFAULT NULL ,
        `UPDATE_TIME` datetime NULL DEFAULT NULL ,
        `LIQUIDATION_TIME` datetime NULL DEFAULT NULL ,
        PRIMARY KEY (`ID`),
        UNIQUE INDEX ${tableName}_ACCOUNT (`ACCOUNT`) USING BTREE
        )
        ENGINE=InnoDB
        DEFAULT CHARACTER SET=latin1 COLLATE=latin1_swedish_ci
        AUTO_INCREMENT=2
        ROW_FORMAT=DYNAMIC;
    </update>

	<insert id="insertMatchFlow">
		INSERT INTO T_MATCH_FLOW
		(ID,SELLSIDE_ORDER_ID,SELLSIDE_ACCOUNT,BUYSIDE_ORDER_ID,BUYSIDE_ACCOUNT,PRICE,AMOUNT,INSERT_TIME)
		VALUES
		(#{0},#{1},#{2},#{4},#{3},#{5},#{6},#{7})
	</insert>


	<insert id="insertUserCancelOrder">
		INSERT INTO T_USER_ORDER(ORDER_ID,ACCOUNT,CANCEL_TIME)
		VALUES
		(#{0},#{1},#{2})
	</insert>


</mapper>
